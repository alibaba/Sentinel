# JVM-SANDBOX
>基于JVM的实时无侵入AOP框架容器


## 项目简介

#### JVM-SANDBOX的核心功能是什么？

##### 1.实时无侵入AOP框架
在常见的AOP框架实现方案中，有静态编织和动态编织两种。

###### 静态编织
静态编织发生在字节码生成时根据一定框架的规则提前将AOP字节码插入到目标类和方法中，实现AOP；
###### 动态编织
动态编织则允许在JVM运行过程中完成指定方法的AOP字节码增强.
常见的动态编织方案大多采用重命名原有方法，再新建一个同签名的方法来做代理的工作模式来完成AOP的功能(常见的实现方案如CgLib)，但这种方式存在一些应用边界：
- 侵入性
  对被代理的目标类需要进行侵入式改造。比如：在Spring中必须是托管于Spring容器中的Bean。
- 固化性
  目标代理方法在启动之后即固化，无法重新对一个已有方法进行AOP增强。

###### 热部署
还有一些实现AOP的方式是通过类似热部署的方式完成，但现有的热部署实现方案也存在一些应用边界：

- 性能折损巨大
- 对JVM存在侵入性
- 必须启动时显式开启

基于此我通过JDK6所提供的Instrumentation-API实现了利用HotSwap技术在不重启JVM的情况下实现对任意方法的AOP增强。而且性能开销还在可以接受的范围之内。

#####2. 动态可插拔容器
为了实现沙箱模块的动态热插拔，容器客户端和沙箱动态可插拔容器采用HTTP协议进行通讯，底层用Jetty8作为HTTP服务器。

#### What can the JVM-SANDBOX do？

在JVM沙箱（以下简称沙箱）的世界观中，任何一个Java方法的调用都可以分解为`BEFORE`、`RETURN`和`THROWS`三个环节，由此在三个环节上引申出对应环节的事件探测和流程控制机制。

```java
// BEFORE-EVENT
try {

   /*
    * do something...
    */

    // RETURN-EVENT
    return;

} catch (Throwable cause) {
    // THROWS-EVENT
}
```


基于`BEFORE`、`RETURN`和`THROWS`三个环节事件，可以完成很多类AOP的操作。

1. 可以感知和改变方法调用的入参
2. 可以感知和改变方法调用返回值和抛出的异常
3. 可以改变方法执行的流程

    - 在方法体执行之前直接返回自定义结果对象，原有方法代码将不会被执行
    - 在方法体返回之前重新构造新的结果对象，甚至可以改变为抛出异常
    - 在方法体抛出异常之后重新抛出新的异常，甚至可以改变为正常返回

#### JVM沙箱都有哪些可能的应用场景

- 线上故障定位
- 线上系统流控
- 线上故障模拟
- 方法请求录制和结果回放
- 动态日志打印
- 安全信息监测和脱敏

JVM沙箱还能帮助你做很多很多，取决于你的脑洞有多大了。

